//! Wrapper crate for [`termcolor_output_impl`] procedural macro.
//!
//! The reason for this code to be split into two crates is simple: we want to make
//! this functionality available on stable. In fact, this dual-crate system is simply
//! the manual implementation of the code generated by [`proc_macro_hack`].
//!
//! ## What is it
//!
//! The [`termcolor`] crate is a cross-platform implementation for the different console
//! APIs, abstracting away both Linux terminals and Windows consoles. It has, however,
//! a but cumbersome API itself (only a bit though), since for formatting-heavy parts
//! we have to litter our code with explicit styling commands. This crate allows to
//! abstract these things away, providing the interface similar to the standard [`write!`]
//! macro.
//!  
//! [`termcolor_output_impl`]: http://crates.io/crates/termcolor_output_impl
//! [`proc_macro_hack`]: http://github.com/dtolnay/proc-macro-hack
//! [`termcolor`]: http://docs.rs/termcolor
//! [`write!`]: https://doc.rust-lang.org/stable/std/macro.write.html

/// Extension trait for [`WriteColor`] instances.
///
/// This trait is not intended for public use. Its only purpose is to allow us check if the
/// provided value implements [`WriteColor`] in an ergonomic way, without consuming the value if
/// unnecessary, and it is used internally by the [`colored`] macro.
///
/// You'll probably see this trait only in type errors, if the first argument to the macro appears
/// to be of the wrong type.
///
/// ## Example
///
/// ```compile_fail
/// use termcolor_output as tco;
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// tco::write!(0u8, "This won't be written")?;
/// # Ok(())
/// # }
/// ```
///
/// This example yields the following error:
/// ```text
/// error[E0599]: the method `guard` exists for type `u8`, but its trait bounds were not satisfied
///  --> src\lib.rs:35:13
///   |
/// 5 | tco::write!(0u8, "This won't be written")?;
///   |             ^^^ method cannot be called on `u8` due to unsatisfied trait bounds
///   |
///   = note: the following trait bounds were not satisfied:
///           `u8: WriteColor`
///           which is required by `u8: WriteColorGuard`
/// ```
///
/// [`WriteColor`]: https://docs.rs/termcolor/1.0.5/termcolor/trait.WriteColor.html
/// [`write!`]: write
pub trait WriteColorGuard {
    fn guard(&mut self) -> &mut Self {
        self
    }
}
impl<T: termcolor::WriteColor> WriteColorGuard for T {}

#[doc(hidden)]
pub use std;
#[doc(hidden)]
pub use termcolor;
#[doc(hidden)]
pub use termcolor_output_impl;

/// The macro writing colored text.
///
/// Like the standard [`write!`] macro, it takes the writer, format string and the sequence of
/// arguments. The arguments may be either formattable with the corresponding formatter (`Display`
/// for `{}`, `Debug` for `{:?}`, etc.), or the _control sequences_, which are written in
/// macro-like style:
/// - `reset!()` yields call to [`WriteColor::reset`][termcolor::WriteColor::reset];
/// - `fg!(color)`, `bg!(color)`, `bold!(bool)`, `underline!(bool)` and `intense!(bool)` are
/// translated into corresponding `ColorSpec::set_*` calls with the provided arguments.
///
/// Internally, this expands to the following:
/// - imports of all necessary traits;
/// - call to the `guard` method on the [`WriteColorGuard`] trait (as a sanity check);
/// - an immediately called closure, containing:
///   - creation of `ColorSpec`;
///   - calls to `write!` for every formattable input;
///   - updates for `ColorSpec` for every control sequence.
/// Every error generated inside the closure is returned early and yielded by the macro as an
/// [`std::io::Result<()>`].
///
/// When the arguments list is malformed, macro generates a compile error trying to point on the
/// exact origin.
///
/// ## Examples
///
/// Simple formatting is provided in exactly the same way as for standard writes:
/// ```
/// use termcolor_output as tco;
/// # fn write(writer: &mut impl termcolor::WriteColor) {
/// tco::write!(writer, "This text is {} styled", "not").unwrap();
/// # }
/// ```
///
/// Styled formatting is provided by using any formatter argument in format string, wherever you
/// need to apply the style:
/// ```
/// use termcolor_output as tco;
/// # fn write(writer: &mut impl termcolor::WriteColor) {
/// # use termcolor::Color;
/// tco::write!(writer, "This text is not styled\n{}And this is colored", fg!(Some(Color::Blue))).unwrap();
/// # }
/// ```
///
/// You can chain several styling commands by specifying several formatter arguments without text
/// between them:
/// ```
/// use termcolor_output as tco;
/// # fn write(writer: &mut impl termcolor::WriteColor) {
/// # use termcolor::Color;
/// tco::write!(
///     writer,
///     "{}{}{}This text is bold blue on yellow background
///      {}{}{}And this has default colors, but is bold and underlined",
///     fg!(Some(Color::Blue)), bg!(Some(Color::Yellow)), bold!(true),
///     fg!(None), bg!(None), underline!(true),
/// ).unwrap();
/// # }
/// ```
/// Note that the `bold` being set in the first block of control sequences is preserved after the
/// second one.
///
/// And, of course, you can mix ordinary formatting outputs with the control sequences:
///
/// ```
/// use termcolor_output as tco;
/// # fn write(writer: &mut impl termcolor::WriteColor) {
/// # use termcolor::Color;
/// tco::write!(writer, "{}{:?}{} unwraps to {}", bold!(true), Some(0), bold!(false), 0).unwrap();
/// # }
/// ```
///
/// [`write!`]: https://doc.rust-lang.org/std/macro.write.html
/// [`std::io::Result<()>`]: https://doc.rust-lang.org/std/io/type.Result.html
#[macro_export]
macro_rules! write {
    ($($arg:tt)*) => {{
        #[allow(unused_imports)]
        use $crate::{std::io::Write, termcolor::WriteColor, WriteColorGuard};
        $crate::termcolor_output_impl::colored_impl!($($arg)*)
    }}
}

/// The macro writing colored text, with a newline appended.
///
/// For more information, see [`write!`] macro.
///
/// [`writeln!`]: https://doc.rust-lang.org/std/macro.writeln.html
/// [`std::io::Result<()>`]: https://doc.rust-lang.org/std/io/type.Result.html
#[macro_export]
macro_rules! writeln {
    ($w:expr) => {{
        $crate::write!($w, "\n")
    }};
    ($w:expr, $($arg:tt)*) => {{
        $crate::write!($w, $($arg)*).and_then(|()| $crate::writeln!($w))
    }}
}

use std::io::Result;
use termcolor::WriteColor;

/// A convenience function, reset the writer before and after
/// some [`write!`] or [`writeln!`] calls.
///
/// ## Examples
/// ```
/// use termcolor_output as tco;
/// # fn write(writer: &mut impl termcolor::WriteColor) {
/// # use termcolor::Color;
/// tco::reset_guard(writer, |writer| tco::writeln!(writer, "Hello world with {}some styles!", fg!(Some(Color::Blue)))).unwrap();
/// tco::writeln!(writer, "No styles here.").unwrap();
/// # }
/// ```
pub fn reset_guard<W, F>(buf: &mut W, func: F) -> Result<()>
where
    W: WriteColor,
    F: FnOnce(&mut W) -> Result<()>,
{
    buf.reset()?;
    func(buf).and_then(|()| buf.reset())
}
